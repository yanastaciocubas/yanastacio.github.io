<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Llama Quantum Dash — Mini Game</title>
<style>
  :root{
    --bg1: #081224;
    --bg2: #0b1b2a;
    --accent: #ffd166;
    --qubit: #9be7ff;
    --gate: #7d5fff;
    --llama: #D9D6CA;
    --llama-accent: #e09a7b;
    --muted: #9fb3c8;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;color:var(--muted)}
  body{
    display:flex;align-items:center;justify-content:center;
    background:linear-gradient(180deg,var(--bg1),var(--bg2));
    padding:18px;
  }

  .container{
    width:100%;max-width:1100px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    border-radius:14px;padding:14px;box-shadow:0 10px 40px rgba(2,6,12,0.6);
    display:grid;grid-template-columns:1fr 300px;gap:14px;
  }

  .play{
    background:linear-gradient(120deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
    border-radius:10px;padding:10px;position:relative;overflow:hidden;
    display:flex;flex-direction:column;
  }
  canvas{width:100%;height:560px;border-radius:8px;background:transparent;display:block}

  .sidebar{
    padding:12px;border-radius:10px;background:rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:12px;
  }
  .title{display:flex;align-items:center;gap:10px}
  .badge{width:44px;height:44px;border-radius:8px;background:linear-gradient(135deg,var(--accent),#ff9f5a);display:flex;align-items:center;justify-content:center;font-weight:800;color:#102}
  h1{font-size:1.05rem;margin:0;color:#fff}
  .stat{background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;font-weight:700;color:#fff;text-align:center}

  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button{padding:8px 12px;border-radius:10px;border:0;background:linear-gradient(180deg,var(--accent),#ffaf4a);color:#081224;font-weight:700;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.05);color:var(--muted)}

  .hint{font-size:0.86rem;color:var(--muted)}
  .kbd{display:inline-block;background:rgba(255,255,255,0.03);padding:4px 8px;border-radius:6px;margin-left:6px;font-weight:700}

  @media (max-width:980px){
    .container{grid-template-columns:1fr; padding:10px}
    canvas{height:420px}
  }
</style>
</head>
<body>
<div class="container" role="application" aria-label="Llama Quantum Dash game">
  <div class="play">
    <canvas id="game" aria-label="Llama Quantum Dash canvas"></canvas>
    <div id="overlay" style="position:absolute;left:0;right:0;top:8px;display:flex;justify-content:center;pointer-events:none"></div>
  </div>

  <aside class="sidebar" aria-hidden="false">
    <div class="title">
      <div class="badge">LQ</div>
      <div>
        <h1>Llama Quantum Dash</h1>
        <div class="hint">Cute llama runs through a quantum circuit — collect qubits & avoid measurement!</div>
      </div>
    </div>

    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
      <div>
        <div style="font-size:0.8rem;color:var(--muted)">Score</div>
        <div id="score" class="stat">0</div>
      </div>
      <div>
        <div style="font-size:0.8rem;color:var(--muted)">Lives</div>
        <div id="lives" class="stat">3</div>
      </div>
    </div>

    <div style="margin-top:4px">
      <div style="font-size:0.9rem;color:var(--muted)">Controls</div>
      <div style="margin-top:6px">
        <span class="kbd">↑ / W</span> Move Up<br/>
        <span class="kbd">↓ / S</span> Move Down<br/>
        <span class="kbd">Mouse</span> Hover near llama → she runs away!<br/>
        <span class="kbd">R</span> Restart
      </div>
    </div>

    <div class="controls">
      <button id="start">Start</button>
      <button id="pause" class="ghost">Pause</button>
      <button id="reset" class="ghost">Reset</button>
    </div>

    <div style="margin-top:8px;font-size:0.9rem;color:var(--muted)">
      Tips:
      <ul style="margin:6px 0 0 18px;padding:0;color:var(--muted)">
        <li>Get qubits (+10 points)</li>
        <li>Don't touch measurement detectors (−1 life)</li>
        <li>Hover your mouse near the llama to make her run (try it!)</li>
      </ul>
    </div>
    </div>
  </aside>
</div>

<script>
/* Llama Quantum Dash
   - Canvas-based, no external assets
   - Keyboard: Up/Down or W/S
   - Mouse hover: llama flees from cursor
   - Collect qubits, avoid detectors
*/

(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let dpr = Math.min(window.devicePixelRatio || 1, 2);

  function resize() {
    const rect = canvas.getBoundingClientRect();
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = Math.max(600, Math.floor(rect.width * dpr));
    canvas.height = Math.floor((rect.height || 560) * dpr);
    canvas.style.width = rect.width + 'px';
    canvas.style.height = (rect.height || 560) + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  // ensure canvas has a default size if style not set
  canvas.style.width = '100%';
  canvas.style.height = '560px';
  resize();
  window.addEventListener('resize', resize);

  // UI
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const overlay = document.getElementById('overlay');

  // Game state
  let running = false, paused = false;
  let score = 0, lives = 3, best = Number(localStorage.getItem('llama_best')||0);
  let lastTs = 0;

  // Llama entity
  const llama = {
    x: 120, y: canvas.clientHeight / 2, w: 140, h: 110,
    vy: 0, speed: 360, fleeSpeed: 620,
    color: (getComputedStyle(document.documentElement).getPropertyValue('--llama') || '#f4d3c2').trim(),
    accent: (getComputedStyle(document.documentElement).getPropertyValue('--llama-accent') || '#e09a7b').trim(),
    boundingRadius: 56,
    bob: 0
  };

  // Circuit (scrolling left)
  const wires = 5;
  const wireY = [];
  const gates = []; // {x,y,type,width}
  const things = []; // qubits and detectors: {x,y,type,vx,r}
  let scroll = 0;
  let spawnTimer = 0;
  let spawnInterval = 1300;

  // input
  const keys = {};
  window.addEventListener('keydown', (e)=>{ keys[e.key] = true; if (e.key === 'r' || e.key === 'R') restart(); if (e.key === 'p' || e.key === 'P') togglePause(); });
  window.addEventListener('keyup', (e)=>{ keys[e.key] = false; });

  // mouse
  let mouse = {x: -9999, y: -9999};
  window.addEventListener('mousemove', (e)=>{
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
  });
  window.addEventListener('mouseleave', ()=>{ mouse.x = -9999; mouse.y = -9999; });

  // touch -> map to pointer for simple hover behavior
  window.addEventListener('touchstart', (e)=> {
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    mouse.x = t.clientX - rect.left;
    mouse.y = t.clientY - rect.top;
  }, {passive:false});
  window.addEventListener('touchmove', (e)=> {
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    mouse.x = t.clientX - rect.left;
    mouse.y = t.clientY - rect.top;
  }, {passive:false});
  window.addEventListener('touchend', ()=>{ mouse.x = -9999; mouse.y = -9999; });

  // helpers
  function rand(min,max){ return Math.random()*(max-min)+min }
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

  // init wires Y positions
  function resetCircuit(){
    wireY.length = 0;
    const step = canvas.clientHeight / (wires + 1);
    for (let i=1;i<=wires;i++) wireY.push(i * step);
    gates.length = 0;
    things.length = 0;
    scroll = 0;
    spawnTimer = 0;
  }
  resetCircuit();

  // spawn gates occasionally (cosmetic) and things (qubit collectible or detector)
  function spawn() {
    // spawn qubit mostly, detector less frequently
    const w = canvas.clientWidth;
    const x = w + rand(40,120);
    const lane = Math.floor(rand(0, wireY.length));
    const y = wireY[lane] + rand(-18,18);
    if (Math.random() < 0.75) {
      things.push({x,y,type:'qubit',vx:-rand(80,160),r:14,angle:rand(0,Math.PI*2),twinkle:Math.random()*1});
    } else {
      things.push({x,y,type:'detector',vx:-rand(100,190),r:22});
    }

    // cosmetic gate occasionally
    if (Math.random() < 0.45) {
      gates.push({x:x+rand(20,80), y: wireY[Math.floor(rand(0,wireY.length))], type: Math.random()<0.5?'H':'X', w: rand(28,46)});
    }
  }

  // update UI
  function updateUI(){
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    if (score > best){ best = score; localStorage.setItem('llama_best', best); }
  }

  function showOverlay(text){
    overlay.innerHTML = '';
    const el = document.createElement('div');
    el.style.background = 'rgba(0,0,0,0.45)';
    el.style.color = 'white';
    el.style.padding = '8px 12px';
    el.style.borderRadius = '8px';
    el.style.fontWeight = '800';
    el.style.pointerEvents = 'none';
    el.textContent = text;
    overlay.appendChild(el);
  }

  // NEW: draw llama (more llama-like)
  function drawLlama(x,y,scale=1,flip=false){
    ctx.save();
    ctx.translate(x,y);
    if (flip) ctx.scale(-1,1);

    // small vertical bob
    const bob = Math.sin(perf*0.004) * 3 * scale;

    // shadow
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,0,0,0.14)';
    ctx.ellipse(0, 36*scale, 48*scale, 14*scale, 0,0,Math.PI*2);
    ctx.fill();

    // body (rounded, with slight fluff)
    ctx.fillStyle = llama.color;
    roundedRectPath(ctx, -54*scale, -6*scale + bob, 108*scale, 56*scale, 16*scale);
    ctx.fill();

    // fluffy chest / neck fur overlay
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.beginPath();
    ctx.moveTo(-10*scale, 0*scale + bob);
    ctx.quadraticCurveTo(-4*scale, -14*scale + bob, 8*scale, -8*scale + bob);
    ctx.quadraticCurveTo(18*scale, -4*scale + bob, 26*scale, -10*scale + bob);
    ctx.quadraticCurveTo(10*scale, -4*scale + bob, -10*scale, 0*scale + bob);
    ctx.closePath(); ctx.fill();

    // rear fluff / tail
    ctx.save();
    ctx.translate(44*scale, 2*scale + bob);
    ctx.rotate(-0.35);
    roundedRectPath(ctx, -6*scale, -10*scale, 18*scale, 22*scale, 8*scale);
    ctx.fillStyle = llama.accent;
    ctx.fill();
    // tail tuft
    ctx.beginPath();
    ctx.fillStyle = llama.color;
    ctx.ellipse(18*scale, -2*scale, 8*scale, 6*scale, 0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // legs (front and back, layered)
    ctx.fillStyle = '#d1b7a6';
    // front legs (closer to viewer)
    roundedRectPath(ctx, -30*scale, 36*scale + bob, 12*scale, 26*scale, 4*scale);
    ctx.fill();
    roundedRectPath(ctx, 8*scale, 36*scale + bob, 12*scale, 26*scale, 4*scale);
    ctx.fill();

    // hooves
    ctx.fillStyle = '#7a5f4f';
    ctx.fillRect(-30*scale, 56*scale + bob, 12*scale, 6*scale);
    ctx.fillRect(8*scale, 56*scale + bob, 12*scale, 6*scale);

    // neck (slightly angled) and head
    ctx.save();
    ctx.translate(26*scale, -10*scale + bob);
    ctx.rotate(-0.12);
    // neck
    roundedRectPath(ctx, -12*scale, -4*scale, 24*scale, 36*scale, 8*scale);
    ctx.fillStyle = llama.color;
    ctx.fill();

    // head
    ctx.save();
    ctx.translate(20*scale, -28*scale);
    // face main
    ctx.beginPath();
    ctx.fillStyle = llama.color;
    ctx.ellipse(0, 0, 22*scale, 26*scale, 0, 0, Math.PI*2);
    ctx.fill();

    // muzzle (distinct, slightly darker)
    ctx.beginPath();
    ctx.fillStyle = '#e6cdbd';
    ctx.ellipse(6*scale, 8*scale, 12*scale, 8*scale, 0, 0, Math.PI*2);
    ctx.fill();

    // nostrils
    ctx.fillStyle = '#2b2018';
    ctx.beginPath(); ctx.ellipse(4*scale, 9*scale, 2.2*scale, 1.6*scale, 0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(8*scale, 9*scale, 2.2*scale, 1.6*scale, 0,0,Math.PI*2); ctx.fill();

    // eye (friendly)
    ctx.beginPath(); ctx.fillStyle = '#1b1211'; ctx.ellipse(-6*scale, -2*scale, 3.5*scale, 4.5*scale, 0,0,Math.PI*2); ctx.fill();
    // tiny eye shine
    ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.ellipse(-8*scale, -3.5*scale, 1.1*scale, 1.1*scale, 0,0,Math.PI*2); ctx.fill();

    // ear left
    ctx.beginPath();
    ctx.fillStyle = llama.accent;
    ctx.moveTo(-10*scale, -18*scale);
    ctx.quadraticCurveTo(-16*scale, -36*scale, -4*scale, -40*scale);
    ctx.quadraticCurveTo(0*scale, -22*scale, -10*scale, -18*scale);
    ctx.fill();
    // ear right
    ctx.beginPath();
    ctx.fillStyle = llama.accent;
    ctx.moveTo(6*scale, -18*scale);
    ctx.quadraticCurveTo(10*scale, -34*scale, 18*scale, -30*scale);
    ctx.quadraticCurveTo(6*scale, -18*scale, 6*scale, -18*scale);
    ctx.fill();

    // cheek blush
    ctx.beginPath(); ctx.fillStyle = 'rgba(255,120,120,0.14)'; ctx.ellipse(10*scale, 2*scale, 6*scale, 4*scale, 0,0,Math.PI*2); ctx.fill();

    ctx.restore(); // head
    ctx.restore(); // neck + head

    // small saddle decoration (quantum patch)
    ctx.save();
    ctx.translate(-10*scale, -2*scale + bob);
    roundedRectPath(ctx, -14*scale, -6*scale, 28*scale, 12*scale, 4*scale);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gate') || '#7d5fff';
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = `${8*scale}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Ψ', 0, 0);
    ctx.restore();

    ctx.restore();
  }

  // helper: rounded rectangle path
  function roundedRectPath(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.lineTo(x+w-rr, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
    ctx.lineTo(x+w, y+h-rr);
    ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
    ctx.lineTo(x+rr, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
    ctx.lineTo(x, y+rr);
    ctx.quadraticCurveTo(x, y, x+rr, y);
    ctx.closePath();
  }

  // draw circuit wires and gates
  function drawCircuit(scrollOffset){
    const w = canvas.clientWidth;
    // wires
    ctx.save();
    ctx.lineWidth = 2;
    for (let i=0;i<wireY.length;i++){
      const y = wireY[i];
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }

    // gates
    for (let i=gates.length-1;i>=0;i--){
      const g = gates[i];
      g.x += -120 * (1/60) * (1/60) * 0; // keep static relative to world (we'll offset when draw)
      const sx = g.x - scrollOffset;
      if (sx < -120) { gates.splice(i,1); continue; }
      if (sx > -40 && sx < w+80){
        ctx.save();
        ctx.translate(sx, g.y);
        // gate box
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--gate') || '#7d5fff';
        ctx.fillRect(-g.w/2, -18, g.w, 36);
        // label
        ctx.fillStyle = 'white'; ctx.font = '12px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline='middle';
        ctx.fillText(g.type, 0, 0);
        ctx.restore();
      }
    }
    ctx.restore();
  }

  // draw things (qubits + detectors)
  function drawThings(){
    for (const t of things){
      if (t.type === 'qubit'){
        // sparkling orb
        const grd = ctx.createRadialGradient(t.x, t.y, 2, t.x, t.y, t.r*2);
        grd.addColorStop(0, 'rgba(255,255,255,0.98)');
        grd.addColorStop(0.2, 'rgba(155,231,255,0.95)');
        grd.addColorStop(1, 'rgba(155,231,255,0.06)');
        ctx.fillStyle = grd;
        ctx.beginPath(); ctx.ellipse(t.x, t.y, t.r, t.r, t.angle, 0, Math.PI*2); ctx.fill();

        // little sparkle
        ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.7)';
        ctx.fillRect(t.x-1, t.y- t.r - 4 * (0.5 + 0.5*Math.sin(t.twinkle*5)), 2,2);
      } else {
        // detector: stylized measurement device
        ctx.save();
        ctx.translate(t.x, t.y);
        ctx.fillStyle = 'rgba(255,120,120,0.95)';
        roundedRectPath(ctx, -18, -18, 36, 36, 6); ctx.fill();
        ctx.fillStyle='rgba(0,0,0,0.9)';
        ctx.fillRect(-6, -6, 12, 12);
        ctx.restore();
      }
    }
  }

  // collision detection
  function intersectCircleRect(cx,cy,r, rx,ry,rw,rh){
    // circle center cx,cy, radius r ; rect x,y,w,h (x,y at top-left)
    const closestX = clamp(cx, rx, rx+rw);
    const closestY = clamp(cy, ry, ry+rh);
    const dx = cx - closestX, dy = cy - closestY;
    return (dx*dx + dy*dy) < (r*r);
  }

  // handle llama fleeing when mouse near
  function handleLlamaFlee(dt){
    const rect = canvas.getBoundingClientRect();
    const mx = mouse.x, my = mouse.y;
    if (mx < 0 || my < 0 || mx > rect.width || my > rect.height) return false;
    const dx = llama.x - mx;
    const dy = llama.y - my;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const safeRadius = llama.boundingRadius * 1.1;
    if (dist < safeRadius + 80) {
      // compute flee vector away from mouse
      const nx = dx / (dist || 1);
      const ny = dy / (dist || 1);
      llama.vy = -ny * llama.fleeSpeed; // vertical flee
      // make llama also dash horizontally a bit
      llama.x += nx * 20 * (dt/16);
      // small cooldown bob
      llama.bob = 1.2;
      return true;
    }
    return false;
  }

  // main update
  function update(dt){
    if (!running || paused) return;

    // input vertical movement
    let vyInput = 0;
    if (keys['ArrowUp'] || keys['w'] || keys['W']) vyInput = -llama.speed;
    if (keys['ArrowDown'] || keys['s'] || keys['S']) vyInput = llama.speed;
    // mixing with current vy (flee effect)
    llama.vy = (llama.vy*0.7) + (vyInput*0.3);

    // mouse hover flee: stronger effect; override vertical input a bit
    const fled = handleLlamaFlee(dt);
    if (fled) {
      // slightly boost vertical speed if fleeing
      llama.vy *= 1.1;
    }

    // apply motion
    llama.y += llama.vy * dt / 1000;
    // bobbing
    llama.bob *= 0.92;
    llama.y += Math.sin(perf)*0.6 * llama.bob;

    // clamp within canvas
    llama.y = clamp(llama.y, 60, canvas.clientHeight - 80);

    // scroll world to left
    const scrollSpeed = 160 + score*2;
    scroll += scrollSpeed * dt / 1000;

    // spawn things
    spawnTimer += dt;
    if (spawnTimer > spawnInterval) { spawn(); spawnTimer = 0; spawnInterval = clamp(900 - score*4, 600, 1600); }

    // update things positions (move left)
    for (let i=things.length-1;i>=0;i--){
      const t = things[i];
      t.x += t.vx * dt / 1000;
      if (t.type === 'qubit') {
        t.angle += 0.02;
        t.twinkle += 0.05;
      }
      // off-screen removal
      if (t.x < -80) things.splice(i,1);
      else {
        // collision with llama
        // approximate llama rect
        const rx = llama.x - 48, ry = llama.y - 48, rw = 96, rh = 96;
        if (intersectCircleRect(t.x, t.y, t.r, rx, ry, rw, rh)) {
          if (t.type === 'qubit') {
            score += 10;
            // sparkle animation
            sparkle(t.x, t.y);
          } else {
            lives = Math.max(0, lives - 1);
            showOverlay('Ouch — measurement!'); setTimeout(()=>overlay.innerHTML='',800);
            // slight knockback
            llama.x = Math.max(72, llama.x - 40);
          }
          things.splice(i,1);
          updateUI();
          if (lives <= 0) endGame();
        }
      }
    }

    // gates cleaning: remove gates that are far left
    for (let i=gates.length-1;i>=0;i--){
      if (gates[i].x - scroll < -200) gates.splice(i,1);
    }

    // occasionally push a cosmetic gate left to maintain look
    if (Math.random() < 0.01) {
      gates.push({x: canvas.clientWidth + rand(40,220) + scroll, y: wireY[Math.floor(rand(0, wireY.length))], type: Math.random()<0.6?'H':'X', w: rand(28,44)});
    }

    // gentle auto-correct llama x toward base as she flees a bit horizontally
    llama.x = clamp( llama.x + (120 - llama.x) * 0.02, 72, canvas.clientWidth - 120 );
  }

  // tiny sparkle effect (visual only)
  const sparks = [];
  function sparkle(x,y){
    for (let i=0;i<8;i++){
      sparks.push({x,y, vx: rand(-80,80), vy: rand(-180,-40), life: 500 + rand(0,400)});
    }
  }

  // draw everything
  let perf = 0;
  function draw(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    // clear with slight gradient
    ctx.clearRect(0,0,w,h);
    // background stars / gradient
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, 'rgba(12,20,34,0.9)');
    g.addColorStop(1, 'rgba(2,6,12,0.95)');
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);

    // moving faint nebula
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.beginPath();
    ctx.ellipse(w*0.5 - (scroll%400)/2, h*0.3, 420, 180, 0,0,Math.PI*2);
    ctx.fillStyle = 'rgba(140,80,180,0.12)'; ctx.fill();
    ctx.restore();

    // draw circuit wires & gates (offset by scroll)
    ctx.save();
    ctx.translate(- (scroll % (w+400)), 0);
    drawCircuit(scroll % (w+400));
    // draw second pass to cover wrapping
    ctx.translate(w+400, 0);
    drawCircuit((scroll + w+400) % (w+400));
    ctx.restore();

    // draw things
    drawThings();

    // draw llama near foreground
    drawLlama(llama.x, llama.y + Math.sin(perf*0.004)*3, 1.0);

    // draw sparks
    for (let i=sparks.length-1;i>=0;i--){
      const s = sparks[i];
      s.x += s.vx * (dtCache/1000);
      s.y += s.vy * (dtCache/1000);
      s.life -= dtCache;
      if (s.life <= 0) sparks.splice(i,1);
      else {
        ctx.fillStyle = 'rgba(255,255,255,' + (s.life/900) + ')';
        ctx.fillRect(s.x, s.y, 3,3);
      }
    }

    // subtle HUD
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(14, 14, 170, 44);
    ctx.fillStyle = 'white';
    ctx.font = '14px sans-serif';
    ctx.fillText('Score: ' + score, 24, 36);
  }

  // end game
  function endGame(){
  running = false;

  const bestPrev = Number(localStorage.getItem('llama_best')||0);
  if (score > bestPrev) localStorage.setItem('llama_best', score);

  // Build modal into the existing #overlay
  overlay.innerHTML = `
    <div style="
      background: rgba(2,6,12,.85);
      border:1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(6px);
      color:#fff; padding:18px 16px; border-radius:12px;
      display:flex;flex-direction:column; gap:10px; align-items:center;
      pointer-events:auto; box-shadow:0 12px 40px rgba(0,0,0,.45);
    ">
      <div style="font-size:1rem;opacity:.9">Game Over</div>
      <div style="font-weight:800;font-size:1.2rem">Score: ${score}</div>
      <div style="font-size:.9rem;color:#cfe3ff">Best: ${localStorage.getItem('llama_best')}</div>
      <div style="display:flex;gap:8px;margin-top:6px">
        <button id="overlayRestart" style="
          padding:8px 12px;border-radius:10px;border:0;
          background:linear-gradient(180deg,var(--accent),#ffaf4a);
          color:#081224;font-weight:800;cursor:pointer">Restart</button>
        <button id="overlayClose" style="
          padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.1);
          background:transparent;color:var(--muted);font-weight:700;cursor:pointer">Close</button>
      </div>
      <div style="font-size:.8rem;color:var(--muted);margin-top:4px">Tip: Hover near the llama to make her sprint away 🦙💨</div>
    </div>
  `;

// wire modal buttons
  document.getElementById('overlayRestart').onclick = () => { overlay.innerHTML = ''; restart(); };
  document.getElementById('overlayClose').onclick = () => { overlay.innerHTML = ''; };
}

  // start / reset / pause
  function startGame(){
    if (!running) {
      running = true; paused = false;
      if (score === 0 && lives === 3) { /* first start */ }
      lastTs = performance.now();
      requestAnimationFrame(tick);
      overlay.innerHTML = '';
      document.getElementById('start').textContent = 'Restart';
    } else {
      // restart quickly
      running = false;
      setTimeout(()=> { score = 0; lives = 3; updateUI(); resetCircuit(); llama.x = 120; llama.y = canvas.clientHeight/2; running=true; lastTs = performance.now(); requestAnimationFrame(tick); }, 80);
    }
  }
  function restart(){
    running = false;
    setTimeout(()=> { score = 0; lives = 3; updateUI(); resetCircuit(); llama.x = 120; llama.y = canvas.clientHeight/2; running=true; lastTs = performance.now(); requestAnimationFrame(tick); }, 80);
  }
  function togglePause(){
    if (!running) return;
    paused = !paused;
    document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
    if (!paused) { lastTs = performance.now(); requestAnimationFrame(tick); }
    if (paused) showOverlay('Paused');
    else overlay.innerHTML = '';
  }
  document.getElementById('start').addEventListener('click', startGame);
  document.getElementById('pause').addEventListener('click', togglePause);
  document.getElementById('reset').addEventListener('click', restart);
  document.getElementById('reset').addEventListener('dblclick', ()=>{ score = 0; lives = 3; updateUI(); });

  // main loop
  let dtCache = 16;
  function tick(ts){
    const dt = Math.min(40, ts - lastTs);
    dtCache = dt;
    lastTs = ts;
    perf += dt;
    update(dt);
    draw();
    if (running && !paused) requestAnimationFrame(tick);
  }

  // initial UI
  updateUI();
  showOverlay('Press Start to play');

  // expose for debugging
  window.llamaQuantum = { startGame, restart, togglePause };

})();
</script>
</body>
</html>
